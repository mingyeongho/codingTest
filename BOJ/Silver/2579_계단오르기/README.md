### Algorithm: 다이나믹 프로그래밍

> [!abstract] 요구사항 분석
> 시간 제한: 1초
> 메모리 제한: 128MB

> [!question] 문제
> 계단 오르는 데는 다음과 같은 규칙이 있다.
>
> 1. 계단은 한 번에 한 계단씩 또는 두 계단씩 오를 수 있다. 즉, 한 계단을 밟으면서 이어서 다음 계단이나, 다음 다음 계단으로 오를 수 있다.
> 2. 연속된 세 개의 계단을 모두 밟아서는 안 된다. 단, 시작점은 계단에 포함되지 않는다.
> 3. 마지막 도착 계단은 반드시 밟아야 한다.
>
> 따라서 첫 번째 계단을 밟고 이어 두 번째 계단이나, 세 번째 계단으로 오를 수 있다. 하지만, 첫 번째 계단을 밟고 이어 네 번째 계단으로 올라가거나, 첫 번째, 두 번째, 세 번째 계단을 연속해서 모두 밟을 수는 없다.
>
> 각 계단에 쓰여 있는 점수가 주어질 때 이 게임에서 얻을 수 있는 총 점수의 최댓값을 구하는 프로그램을 작성하시오.

> [!info] 입력
> 입력의 첫째 줄에 계단의 개수가 주어진다.
>
> 둘째 줄부터 한 줄에 하나씩 제일 아래에 놓인 계단부터 순서대로 각 계단에 쓰여 있는 점수가 주어진다. 계단의 개수는 300이하의 자연수이고, 계단에 쓰여 있는 점수는 10,000이하의 자연수이다.

> [!success] 출력
> 첫째 줄에 계단 오르기 게임에서 얻을 수 있는 총 점수의 최댓값을 출력한다.

> [!example] 예시1
> input
>
> ```
> 6
> 10
> 20
> 15
> 25
> 10
> 20
> ```
>
> output
>
> ```
> 75
> ```

> [!abstract] 내가 이해한 내용
> 총 점수의 최댓값
> 점수가 큰 거를 밟으면 유리하다.

> [!tip] 문제의 본질 (어떠한 것을 나에게 물어보고 있는지)
> 다이나믹 프로그래밍

> [!hint] 아이디어
> 계단의 개수
> 1: 1
> 2: 1 -> 2
> 3: 1 -> 3 / 2 -> 3
> 4: 1 -> 2 -> 4 / 1 -> 3 -> 4 / 2 -> 3 -> 4
> 5: 1 -> 2 -> 4-> 5 / 1 -> 3 -> 5 / 2 -> 3 -> 5 / 2 -> 4 -> 5
> 6: 1 -> 2 -> 4 -> 6 / 1 -> 3 -> 4 -> 6 / 1 -> 3 -> 5 -> 6 / 2 -> 3 -> 5 -> 6 / 2 -> 4 -> 6

> [!success] 복잡도 분석
> 시간 복잡도:
> 공간 복잡도:

---

> [!info] 다른 사람의 풀이에서 알게된
> 점화식을 찾는 DP문제
> 마지막 도착 계단은 반드시 밟아야 한다라는 규칙 때문에 도착지부터 생각하는 방식의 접근이 더 쉽다.
> dp[n] 은 n번째 계단에 올랐을 때 얻을 수 있는 최댓값
> 어느 계단에서 올라왔을지 생각
>
> 1. n-1 번째 계단에서 오는 경우 (한 칸 올라옴)
>    `dp[n] = dp[n-3] + stairs[n-1] + stairs[n]`
>    2칸 연속으로 올라올 수 없으므로 dp[n-3] + stairs[n-1] + stairs[n]
> 2. n-2 번째 계단에서 오는 경우 (두 칸 올라옴)
>    `dp[n] = dp[n-2] + stairs[n]`
>
> `dp[n] = max(한 칸 전에서 올라왔을 경우, 두 칸 전에서 올라왔을 경우)` > [출처](https://v3.leedo.me/devs/64)

---

[파이썬 웹 에디터](https://replit.com/@alsrudgh0210/KhakiPrettyClient#main.py)(커서를 사용하니까 다 알려줌;;)
