### Algorithm: 스택

> [!question] 문제
> 크기가 N인 수열 A = A1, A2, ..., AN이 있다. 수열의 각 원소 Ai에 대해서 오큰수 NGE(i)를 구하려고 한다. Ai의 오큰수는 오른쪽에 있으면서 Ai보다 큰 수 중에서 가장 왼쪽에 있는 수를 의미한다. 그러한 수가 없는 경우에 오큰수는 -1이다.
>
> 예를 들어, A = [3, 5, 2, 7]인 경우 NGE(1) = 5, NGE(2) = 7, NGE(3) = 7, NGE(4) = -1이다. A = [9, 5, 4, 8]인 경우에는 NGE(1) = -1, NGE(2) = 8, NGE(3) = 8, NGE(4) = -1이다.

> [!info] 입력
> 첫째 줄에 수열 A의 크기 N (1 ≤ N ≤ 1,000,000)이 주어진다. 둘째 줄에 수열 A의 원소 A1, A2, ..., AN (1 ≤ Ai ≤ 1,000,000)이 주어진다.

> [!success] 출력
> 총 N개의 수 NGE(1), NGE(2), ..., NGE(N)을 공백으로 구분해 출력한다.

> [!abstract] 내가 이해한 내용
> 수열이 주어질 때 각 값에 대해 오른쪽에 있으면서 현재값보다 큰 값을 구하여라

> [!tip] 문제의 본질 (어떠한 것을 나에게 물어보고 있는지)
> 시간복잡도가 $O(N)$ 의 로직 작성
> 스택을 사용해서 해결
> 배열을 스캔하며 한번에 오큰수를 구하여야 한다.

---

> [!abstract] 요구사항 분석
> 시간제한: 1초
> N <= 1_000_000

> [!hint] 아이디어
> 너무 어려운디;;;;
> 스택에 아직 오큰수를 찾지 못한 값의 인덱스를 저장한 후
> while문 안에서 스택의 top 값과 arr[i] 값을 비교해서 arr[i]가 더 크면 arr[stack[-1]] 값의 오큰수는 arr[i] 이다.

---

> [!example] 예시1
> input
>
> ```
> 4
> 3 5 2 7
> ```
>
> output
>
> ```
> 5 7 7 -1
> ```

> [!example] 예시2
> input
>
> ```
> 4
> 9 5 4 8
> ```
>
> output
>
> ```
> -1 8 8 -1
> ```

---

> [!success] 복잡도 분석
> 시간 복잡도:
> 공간 복잡도:

---

> [!info] 다른 사람의 풀이에서 알게된 것
> 오큰수는 무조건 -1 아니면 양수를 가지므로 -1을 기본으로 리스트 선언

---

[파이썬 웹 에디터](https://www.onlineide.pro/playground/python?utm_source=online-python&utm_medium=navbar&utm_campaign=onlineidepro)(커서를 사용하니까 다 알려줌;;)
